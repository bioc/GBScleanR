% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/Methods-GbsrGenotypeData.R,
%   R/Methods-GbsrScheme.R
\name{addScheme}
\alias{addScheme}
\alias{addScheme,GbsrGenotypeData-method}
\alias{addScheme,GbsrScheme-method}
\title{#' Build a GbsrScheme object}
\usage{
addScheme(object, crosstype, mating, pop_size, ...)

\S4method{addScheme}{GbsrGenotypeData}(object, crosstype, mating, pop_size)

\S4method{addScheme}{GbsrScheme}(object, crosstype, mating, pop_size)
}
\arguments{
\item{object}{A GbsrGenotypeData object.}

\item{crosstype}{A string to indicate the type of cross conducted with a given generation.}

\item{mating}{An integer matrix to indicate mating combinations. The each element should match with member IDs of the last generation.}

\item{pop_size}{An integer of the number of individuals in a given generation.}

\item{...}{Unused.}
}
\value{
A GbsrScheme object.
}
\description{
GBScleanR uses breeding scheme information to set the expected
number of cross overs in a chromosome which is a required parameter
for the genotype error correction with the Hidden Markov model
implemented in the "clean" function. This function build the object storing
type crosses performed at each generation of breeding and population sizes.
}
\details{
A scheme object is just a data.frame indicating a population size and
a type of cross applied to each generation of the breeding process
to generate the population which you are going to subject to the "clean" function.
The `crosstype` can take either of "selfing", "sibling", "pairing", and "random".
When you set `crosstype = "random"`, you need to specify `pop_size` to indicate how many
individuals were crossed in the random mating.
You also need to specify a matrix indicating combinations of `mating`, in which
each column shows a pair of member IDs indicating parental samples of the cross.
Member IDs are serial numbers starts from 1 and automatically assigned by
[initScheme()] and [addScheme()]. To check the member IDs, run [showScheme()].
Please see the examples section for more details of specifying a `mating` matrix.
The created GbsrScheme object is set in the `scheme` slot of the GbsrGenotypeData object.
}
\examples{
\dontrun{
# Biparental F2 population.
gds <- loadGDS("/path/to/GDS.gds")
gds <- setParents(gds, parents = c("parent1", "parent2"))
# setParents gave member ID 1 and 2 to parent1 and parent2, respectively.
gds <- initScheme(gds, crosstype = "pair", mating = matrix(1:2, nrow = 1, ncol = 2))
# Now the progenies of the cross above have member ID 3.
# If `crosstype = "selfing"` or `"sibling"`, you can omit a `mating` matrix.
gds <- addScheme(gds, crosstype = "self")

# 8-way RILs with sibling mating.
gds <- loadGDS("/path/to/GDS.gds")
gds <- setParents(gds, parents = paste("parent", 1:8, sep = ""))
# setParents set member ID 1 to 8 to parent1 to parent8, respectively.

# If you made crosses of parent1 x parent2, parent3 x parent4, 
# parent5 x parent6, and parent7 x parent8, run the following.
gds <- initScheme(gds, crosstype = "pair", mating = matrix(1:8, nrow = 4, ncol = 2))

# Now the progenies of the crosses above have member ID 9, 10, 11, 
# and 12 for each combination of mating.You can check IDs with showScheme().
showScheme(gds)

# Then, produce 4-way crosses.
gds <- addScheme(gds, crosstype = "pair", mating = matrix(9:12, nrow = 2, ncol = 2))
# 8-way crosses.
gds <- addScheme(gds, crosstype = "pair", mating = matrix(13:14, nrow = 1, ncol = 2))
# Inbreeding by 4 times selfing.
gds <- addScheme(gds, crosstype = "self")
gds <- addScheme(gds, crosstype = "self")
gds <- addScheme(gds, crosstype = "self")
gds <- addScheme(gds, crosstype = "self")

# Execute error correction
gds <- estGeno(gds)

}

}
\seealso{
[addScheme()] and [showScheme()]
}
