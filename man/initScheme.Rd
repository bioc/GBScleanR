% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/Methods-GbsrGenotypeData.R,
%   R/Methods-GbsrScheme.R
\name{initScheme}
\alias{initScheme}
\alias{initScheme,GbsrGenotypeData-method}
\alias{initScheme,GbsrScheme-method}
\title{Build a GbsrScheme object}
\usage{
initScheme(object, crosstype, mating, ...)

\S4method{initScheme}{GbsrGenotypeData}(object, crosstype, mating)

\S4method{initScheme}{GbsrScheme}(object, crosstype, mating, parents)
}
\arguments{
\item{object}{A GbsrGenotypeData object.}

\item{crosstype}{A string to indicate the type of cross conducted with a given generation.}

\item{mating}{An integer matrix to indicate mating combinations. The each element should match with IDs of parental samples which are 1 to N. see Details.}

\item{...}{Unused.}

\item{parents}{Indices of parental lines.}
}
\value{
A GbsrScheme object.
}
\description{
GBScleanR uses breeding scheme information to set the expected
number of cross overs in a chromosome which is a required parameter
for the genotype error correction with the Hidden Markov model
implemented in the "clean" function. This function build the object storing
type crosses performed at each generation of breeding and population sizes.
}
\details{
A GbsrScheme object stores information of a population size, mating combinations and
a type of cross applied to each generation of the breeding process
to generate the population which you are going to subject to the "clean" function.
The first generation should be parents of the population. It is supposed that
[setParents()] has been already executed and parents are labeled in the
GbsrGenotypeData object. The number of parents are automatically recognized.
The "crosstype" of the first generation can be "pairing" or "random" with
`pop_size = N`, where N is the number of parents.
You need to specify a matrix indicating combinations of `mating`, in which each column shows
a pair of parental samples. For example, if you have only two parents, the `mating` matirix
should be `mating = matrix(1:2, nrow = 1, ncol = 2)`. The indices used in the matrix
should match with the IDs labeled to parental samples by [setParents()].
The created GbsrScheme object is set in the `scheme` slot of the GbsrGenotypeData object.
}
\examples{
\dontrun{
# Biparental F2 population.
gds <- loadGDS("/path/to/GDS.gds")
gds <- setParents(gds, parents = c("parent1", "parent2"))
# setParents gave member ID 1 and 2 to parent1 and parent2, respectively.
gds <- initScheme(gds, crosstype = "pair", mating = matrix(1:2, nrow = 1, ncol = 2))
# Now the progenies of the cross above have member ID 3.
# If `crosstype = "selfing"` or `"sibling"`, you can omit a `mating` matrix.
gds <- addScheme(gds, crosstype = "self")

# 8-way RILs with sibling mating.
gds <- loadGDS("/path/to/GDS.gds")
gds <- setParents(gds, parents = paste("parent", 1:8, sep = ""))
# setParents set member ID 1 to 8 to parent1 to parent8, respectively.

# If you made crosses of parent1 x parent2, parent3 x parent4,
# parent5 x parent6, and parent7 x parent8, run the following.
gds <- initScheme(gds, crosstype = "pair", mating = matrix(1:8, nrow = 4, ncol = 2))

# Now the progenies of the crosses above have member ID 9, 10, 11, 
# and 12 for each combination of mating.You can check IDs with showScheme().
showScheme(gds)

# Then, produce 4-way crosses.
gds <- addScheme(gds, crosstype = "pair", mating = matrix(9:12, nrow = 2, ncol = 2))
# 8-way crosses.
gds <- addScheme(gds, crosstype = "pair", mating = matrix(13:14, nrow = 1, ncol = 2))
# Inbreeding by 4 times selfing.
gds <- addScheme(gds, crosstype = "self")
gds <- addScheme(gds, crosstype = "self")
gds <- addScheme(gds, crosstype = "self")
gds <- addScheme(gds, crosstype = "self")

# Execute error correction
gds <- clean(gds)
}

}
\seealso{
[addScheme()] and [showScheme()]
}
